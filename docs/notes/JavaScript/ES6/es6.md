# ES6
## 1.var let const区别
三者的区别可围绕下面5点展开:
1. 变量提升
- var声明的变量存在变量提升，变量可以在声明之前调用，值为undefined
- let const不存在变量提升，声明的变量一定要在声明后使用
2. 暂时性死区
- var 不存在暂时性死区
- let const存在暂时性死区，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
3. 块级作用域
- var不存在块级作用域
- let和const存在块级作用域
4. 重复声明
- var允许重复声明变量
- let和const在同一作用域下不允许重复声明变量
5. 修改声明的变量
- var和let可以
- const声明一个只读的常量，一旦声明，常量的值就不能改变
6. 使用
- 能用const的情况尽量使用const，其他情况大多数使用let，避免使用var  

## 2.箭头函数与普通函数的区别  

1. **箭头函数不会创建自己的this**   


>箭头函数不会创建自己的this，所以它没有自己的
this， 它只会从自己的作用域链的上一层继承this。

2. **箭头函数继承而来的this指向永远不变**（！！）

>箭头函数没有自己的this， 它会捕获自己在定义时（注意
是定义时，不是调用时）所处的外层执行环境的this，并继
承这个this值。所以，箭头函数中this的指向在它被定义的
时候就己经确定了，之后永远不会改变。


3. .call()/.apply()/.bind()无法改变箭头函数中this的指向  

>.call()/.apply()/.bind()方法可以用来动态修改函数执行时
this的指向，但由于箭头函数的this定义时就已经确定且永
远不会改变。所以使用这些方法永远也改变不了箭头函数
this的指向，虽然这么做代码不会报错。

4. 箭头函数不能作为构造函数使用
>构造函数的new简单来说
分为四步：
① JS内部首先会先生成一个对象；  
②再把函数中的this指向该对象；
③然后执行构造函数中的语句；
④最终返回该对象实例  

>但是因为箭头函数没有自己的this，它的this其实是继
承了外层执行环境中的this， 且this指向永远不会随在哪里
调用、被谁调用而改变，所以箭头函数不能作为构造函数
使用，或者说构造函数不能定义成箭头函数，否则用new调
用时会报错！

5. 箭头函数没有自己的arguments
箭头函数没有自己的arguments对象。在箭头函数中访问
arguments实际上获得的是外层局部 （函数）执行环境中的
值。  

6. 箭头函数没有原型prototype

```js
let sayHi =()=>{
console . log ("Hello World !")  
};
console. log (sayHi. prototype); // undefined
```
7. 箭头函数不能用作Generator函数，不能使用yeild关键
字
