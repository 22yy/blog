---
# 这是页面的图标
icon: page
# 这是侧边栏的顺序
order: 1
# 设置写作时间
date: 2022-08-05
tag:
  - HTTP
---
<!-- more -->


# HTTP

![http](./images/HTTP.png)

## 1.HTTP 是什么

::: info
HTTP是超文本传输协议（Hyper Transfer Protocol)  
HTTP 是一个在计算机世界里专门在**两点**之间传输文字、图片、音频、视频等**超文本数据**的**约定和规范**  
:::


那HTTP 是⽤于从互联⽹服务器传输超⽂本到本地浏览器的协议 ，这种说法正确吗？  
这种说法是不正确的。因为也可以是「服务器< -- >服务器」，所以采⽤两点之间的描述会更准确。

## 2.HTTP状态码  

五大类HTTP状态码   

|  | 含义 |
| :----:| :----: |
| 1xx | 提示信息，表示目前是协议处理的中间状态，还需要后续操作 |
| 2xx | 成功，报文已经收到并被成功处理 |
| 3xx | 重定向，资源位置发生改变，需要客户端重新发送请求 |
| 4xx | 客户端错误，请求报文有误，服务器无法处理 |
| 5xx | 服务器错误，服务器在处理请求时内部发生了错误 |  

- 2xx 成功

  - [200 OK] :请求成功,如果是非head请求，服务器返回的响应头都会有body数据  

  - [204 No Content] ：与200 OK基本形同，但响应头没有body数据,包含header和状态行  

  - [206 Partial Content] : 响应返回的body数据不是资源的全部，包含由Content-Range指定范围的实体内容，应用于HTTP分块下载或断点重传

- 3xx 重定向
  - [301 Moved Permanently] : 永久重定向，请求的资源不存在了，已经被分配了新的URL  

  - [302 Found] : 临时重定向，请求的资源还在，但暂时需要用另一个URL访问  

  >301 和 302 都会在响应头里使用字段Location，指明后续要跳转的URL，浏览器会自动重定向新的URL  

  - [303 See Other] : 请求的资源存在着另一个URI，应使用GET方法定向获取请求的资源 

  >当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做。  

  - [304 Not Modified] : 不具有跳转含义，表示资源未修改，重定向已存在的缓存文件，也称缓存重定向，用于缓存控制

- 4xx

  - [400 Bad Request]：客户端请求的报文有误，服务器无法处理 ；浏览器会像200 OK一样对待该状态码 

  - [403 Forbidden] : 服务器禁止访问资源，不是客户端请求出错  

  - [404 Not Found] : 请求的资源在服务器上不存在或未找到  

- 5xx   

  - [500 Internal Server Error] : 服务端在执行请求时发生错误，也可能是Web应用存在的Bug或某些临时故障  

  - [501 Not Implemented] : 客户端请求的功能还不支持  

  - [502 Bad GateWay] : 服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误  

  - [503 Service Unavailable] : 服务器当前很忙。暂时无法响应，如果事先得知解除以上状况需要的时间，可以写入Retry-After首部字段在返回给客户端  


## 3.HTTP 常见字段

- Host 字段；客户端发送请求时，⽤来指定服务器的域名。可以将请求发往「同⼀台」服务器上的不同⽹站

```http
Host:www.A.com
```  

- Content-Length 字段：服务器在返回数据时，本次回应的数据⻓度。  

- Connection 字段：常⽤于客户端要求服务器使⽤ TCP 持久连接，以便其他请求复⽤


>HTTP/1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为
Keep-Alive 。


- Content-Type 字段:服务器响应时使用的数据格式

```http
Content-Type: text/html; charset=utf-8  

上⾯的类型表明，发送的是⽹⻚，⽽且编码是UTF-8。

客户端请求的时候，可以使⽤ Accept 字段声明⾃⼰可以接受哪些数据格式。

Accept: */*  

上⾯代码中，客户端声明⾃⼰可以接受任何格式的数据。
```

- Content-Encoding 字段:说明数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式  

```http
Content-Encoding: gzip  
服务器返回的数据采⽤了 gzip ⽅式压缩，告知客户端需要⽤此⽅式解压。
客户端在请求时，⽤ Accept-Encoding 字段说明⾃⼰可以接受哪些压缩⽅法。
Accept-Encoding: gzip, deflate
```  

- Cache-Control 用来指定当前的请求或者回复，是否使用缓存机制


## 4.HTTP 特性 

1. 基于TCP/IP  
   - http协议是基于TCP/IP协议之上的应用层协议  

2. 基于请求-响应模式
    - 请求从客户端发出，服务器响应请求并返回

3. 无状态保存  
   - 减轻服务器的负担，能够把更多的 CPU 和内存⽤来对外提供服务。它在完成有关联性的操作时会⾮常麻烦。解法⽅案有很多种，其中 ⽐较简单的⽅式⽤ Cookie 技术。

4. 无连接 
   - 限制每次连接只处理一个请求，服务器处理完客户请求，并收到客户的应答后即断开连接

5. 明文传输 
   - 传输过程中的信息，是可⽅便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接⾁眼查看，为我们调试⼯作带了极⼤的便利性。

## 5.HTTP/1.1  

### 5.1 相比HTTP/1.0改进
1. ⻓连接
   - HTTP/1.0 每发起⼀个请求，都要新建⼀次 TCP 连接（三次握⼿），⽽且是串⾏请求，增加了通信开销。
   - HTTP/1.1 采用⻓连接，也叫持久连接。只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。  

2. 管道⽹络传输  
   - 在同⼀个 TCP 连接⾥⾯，客户端可以同时发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。
   - 服务器则是按照请求顺序依次响应    

### 5.2 缺点

1. 队头阻塞
   - 发送的请求中有一个因为某种原因堵塞无法响应时，后面排队的请求也会被堵塞

2. 请求只能由客户端发送，服务器被动响应
3. 请求 / 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩 Body 的部分；
4. 发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多
5. 没有请求优先级控制；


## 6.HTTP/2

>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

### 6.1 HTTP/2 相⽐ HTTP/1.1 性能上的改进

1. 头部压缩
   - 同时发送多个头部相同或相似的请求，协议会消除重复的部分
   - 用的是HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号，提⾼速度。  

2. ⼆进制格式
   - 不采用HTTP/1.1 ⾥的纯⽂本形式的报⽂，全⾯采⽤了⼆进制格式，头信息和数据体都是⼆进制，统称为帧（frame）：头信息帧和数据帧。  

3. 多路复用
   - 一个连接中并发多个请求或回应，不用按顺序一一对应
   - 不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟
   - 当一个请求非常耗时，先回应已处理好的部分，回应其他请求后再回应该请求剩下的部分  

4. 数据流
   - 每个请求或回应的所有数据包，称为⼀个数据流（ Stream ），每个数据流都有编号
   - 客户端可以指定数据流的优先级。优先级⾼服务器就先响应。  

5. 服务器推送  
   - 服务不再是被动地响应，也可以主动向客户端发送消息。
   - 浏览器请求HTML时，提前吧可能会用到的JS，CSS等推送给客户端  

### 6.2 缺陷

>HTTP/2 多个请求复⽤⼀个TCP连接，⼀旦发⽣丢包，触发TCP重传机制，就会阻塞住所有的 HTTP 请求。  


## 7.HTTP/3

> HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP, 不管顺序，也不管丢包的，不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的⼀个丢包全部重传问题。

1. 基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。  
    - 某个流发生丢包时，只会阻塞这个流，不影响其他
    - 头部压缩算法升级为QPack  


## 8.HTTPS

### 8.1 HTTP与HTTPS

1. 概念
   >HTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

2. HTTP和HTTPS区别
    - http是超文本传输协议，信息是明文传输，https则是具有安全性的SSL加密传输协议
    - http的默认端口是80，https的默认端口是443
    - https比http多了加密传输，网络身份认证的功能
    - https协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。  

### 8.2 HTTPS解决了HTTP哪些问题
1. 混合加密
    HTTPS 采⽤的是对称加密和⾮对称加密结合的「混合加密」⽅式，防止用户信息被获取
      - 在通信建⽴前采⽤⾮对称加密的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。
      - 在通信过程中全部使⽤对称加密的「会话秘钥」的⽅式加密明⽂数据

2. 摘要算法  
    为数据⽣成独⼀⽆⼆的「指纹」，⽤于校验数据的完整性，解决了篡改的⻛险。

3. 数字证书    
     将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。  
     通过数字证书的⽅式保证服务器公钥的身份，解决冒充的⻛险。  


### 8.3 HTTPS如何建立连接
1. 三次握手
2. 建立SSL/TLS连接，基本流程：
  - 客户端向服务器索要并验证服务器的公钥。
  - 双⽅协商⽣产「会话秘钥」。
  - 双⽅采⽤「会话秘钥」进⾏加密通信。

详细过程：
   1. ClientHello  
   客户端发起加密通信的请求，并生成一个随机数发送给服务器

   2. SeverHello  
   服务器收到请求后，会将网站的证书信息（包含公钥）传送一份给客户端，同时生成第二个随机数发送
   
   3. 客户端回应  
    客户端收到后会用浏览器或者操作系统的CA证书验证证书合法性，并提取出公钥，然后生成第三个随机数发送
    此时客户端发送的信息是用公钥加密的，只有对应的服务器有私钥解密

   4. 服务器回应   
     服务器收到后用私钥解密，将三个随机数用算法生成`会话密钥`，客户端也一样，生成的密钥是一样的  


⾄此，整个 SSL/TLS 的握⼿阶段全部结束。接下来，客户端与服务器进⼊加密通信，就完全是使⽤普通的 HTTP
协议，只不过⽤「会话秘钥」加密内容。   

>SSL连接总结： 采用非对称加密（公钥和私钥）来商量会话密钥（对称加密）是多少，商量完成后就用这个会话密钥作为对称加密的密钥来进行通信

采⽤「混合加密」的⽅式的原因：  
 - 对称加密只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。
 - ⾮对称加密使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度慢  


## 9.HTTP方法  

1. GET
    - 请求从服务器获取资源，这个资源可以是静态的⽂本、⻚⾯、图⽚视频等。  

2. POST
    - 向 URI 指定的资源提交数据，数据就放在报⽂的 body ⾥。

3. PUT
    - PUT方法主要用来传输文件，就像FTP协议的文件上传一样。  
但是由于Http/1.1的PUT方法不带验证机制，存在安全性问题，所以一般的网站都不用这个方法来进行文件传输。  

4. HEAD
    - HEAD请求主要用来获取报文首部  

5. DELETE
    - DELETE方法主要是用来删除某个资源,该方法也不带认证机制，所以一般网站并不会对它进行开放使用。  

6. OPTIONS请求
    - 请求的指定资源都支持什么http方法。  

## 10.GET和POST区别

1. 缓存上
     - GET请求会被浏览器主动缓存，POST不会，除非手动设置

2. 可传输数据的长度
     - GET请求在URL中传递的参数有长度限制，POST没有
     - 因为GET参数通过URL传递，POST放在body中，URL在请求头中，大小受限制 

3. 参数数据类型
     - GET只接受ASCII字符，POST没有限制

4. GET请求只能进行url encoding编码，POST支持多种格式

5. 可见性
     - GET请求的参数暴露在URL中，可见，
     - POST请求的参数放在request body中，不可见

6. GET在浏览器回退是无害的，POST会重新发送请求

7. GET产生一个TCP数据包，POST产生两个TCP数据包，对于GET，浏览器会把http的header和data一起发送出去，服务器响应200，返回数据，对于POST，浏览器先发送header，服务器响应100 continue，浏览器发送data，服务器响应200 OK，返回数据
 

## 11.HTTP/1.1如何优化

1. 避免发送HTTP请求
   - 利用**缓存**，如果每次请求的数据都是一样的，把这对「请求-响应」的数据用key-value的形式都缓存在本地，下次就直接读取本地的数据
   - 如果客户端从响应头部中发现响应过期，重新发送请求，请求的Etag头部带上第一次请求响应头部的摘要，服务器收到后，将本地资源的摘要与请求中的摘要作比较，如果不同则响应新的资源，相同则仅返回不含有包体的 304 Not Modified 响应，告诉客户端缓存仍然有效，可以减少响应资源在⽹络中传输的延时

2. 减少HTTP请求次数
   - 减少重定向次数，将重定向的工作交给代理服务器
   - 合并请求：多个访问⼩⽂件的请求合并成⼀个⼤的请求
        - 将多个小图片用`CSS Image Sprites`合成为一个大图片，浏览器就⽤⼀次请求获得⼀个⼤图⽚，再根据 CSS 数据把⼤图⽚切割成多张⼩图⽚。
        - 可以将图⽚的⼆进制数据⽤ base64 编码后，以 URL 的形式潜⼊到 HTML ⽂件，跟随 HTML ⽂件⼀并发送.客户端收到 HTML 后，就可以直接解码出数据，然后直接显示图⽚，不用再发起图片相关请求
    - 按需访问
        - 请求⽹⻚的时候，只获取当前⽤户所看到的⻚⾯资源
        - 按需获取，来减少第⼀时间的 HTTP 请求次数。


3. 减少 HTTP 响应的数据⼤⼩
     - 通过压缩响应资源，降低传输资源的⼤⼩，从⽽提⾼传输效率。

## 12.HTTPS如何优化

  性能消耗的两个环节：   
   - TLS 协议握⼿过程；增加了⽹络延时（最⻓可以花费掉 2 RTT）
   -  握⼿后的对称加密报⽂传输。   


1. 硬件优化   

    - ⼀个好的 CPU，可以提⾼计算性能，因为 HTTPS 连接过程中就有⼤量需要计算密钥的过程，所以这样可以加速TLS 握⼿过程。

2. 协议优化   

- 密钥交换算法优化：
     - 密钥交换算法应该选择 ECDHE 算法，⽽不⽤ RSA 算法，因为 ECDHE 算法具备前向安全性，⽽且客户端可以在第三次握⼿之后，就发送加密应⽤数据，节省了 1 RTT  

- TLS升级
     - 把 TLS 1.2 升级成 TLS 1.3，TLS 1.3 ⼤幅度简化了握⼿的步骤，完成 TLS 握⼿只要 1RTT，⽽且安全性更⾼。
     - TLS 1.3 把 Hello 和公钥交换这两个消息合并成了⼀个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握⼿。
     - TLS1.3 对于密钥交换算法，废除了不⽀持前向安全性的 RSA 和 DH 算法，只⽀持 ECDHE 算法  

3. 证书优化  

- 证书传输优化
   - 对于服务器的证书应该选择椭圆曲线（ECDSA）证书，⽽不是 RSA 证书，因为在相同安全强度下， ECC 密钥⻓度⽐ RSA短的多。

- 证书验证优化
   - 服务器应该开启 OCSP Stapling 功能，由服务器预先获得 OCSP 的响应，并把响应结果缓存起来，这样 TLS握⼿的时候就不⽤再访问 CA 服务器，减少了⽹络通信的开销，提⾼了证书验证的效率  

>CRL 证书吊销列表（Certificate Revocation List），由 CA 定期更新，客户端收到服务器的证书后会下载此列表并遍历检验证书的合法性，但随着吊销证书的增多，列表会越来越⼤，下载的速度就会越慢    
>使用 OCSP 在线证书状态协议（Online Certificate Status Protocol）来查询证书的有效性，它是向 CA 发送查询请求，让 CA 返回证书的有效状态，不必像 CRL ⽅式客户端需要下载⼤⼤的列表   

> OCSP 需要向 CA 查询，因此也要发⽣⽹络请求，但如果⽹络状态不好，或者CA 服务器繁忙，也会导致客户端在校验证书这⼀环节的延时变⼤。

>OCSP Stapling，其原理是：**服务器**向 CA 周期性地查询证书状态，获得⼀个带有时间戳和签名的响应结果并缓存它，客户端发起连接请求时，服务器会「响应结果」在 TLS 握⼿过程中发给客户端。由于有签名的存在，服务器⽆法篡改，因此客户端就能得知证书是否已被吊销了，客户端就不需要再去查询     

4. 会话复用
- Session ID
   - 客户端和服务器⾸次 TLS 握⼿连接后，双⽅会在内存缓存会话密钥，并⽤唯⼀的Session ID 来标识，Session ID 和会话密钥相当于 key-value 的关系。客户端再次连接时，hello 消息⾥会带上 Session ID，服务器收到后就会从内存找，找到了就直接用，跳过其他过程，当然为了安全性，内存中的会话密钥会定期失效     
      - 随着客户端的增多，服务器的内存压⼒也会越⼤。   

- Session Ticket  
   - 服务器不再缓存每个客户端的会话密钥，⽽是把缓存的⼯作交给了客户端，类似于 HTTP 的 Cookie  

   - 客户端与服务器⾸次建⽴连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上次的会话密钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信。  

- Pre-shared Key

   -  Session ID 和 Session Ticket ⽅式都需要在 1 RTT 才能恢复会话。
   -  对于TLS1.3只需要 0 RTT，重连时，客户端会把 Ticket和 HTTP 请求⼀同发送给服务端，这种⽅式叫 Pre-shared Key